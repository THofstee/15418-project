{
  "name": "15418-project",
  "tagline": "Final project for CMU 15-418.",
  "body": "## Proposal\r\n### Summary\r\nI will implement the irradiance map solution of [CloudLight](https://research.nvidia.com/publication/cloudlight-system-amortizing-indirect-lighting-real-time-rendering/) and compare performance and quality tradeoffs to local computation.\r\n\r\n### Background\r\nCloud rendering is a promising platform for graphics rendering in the future. Rendering (games) in the cloud has the potential for methods that would be unreasonable for a local machine, such as possibly raytracing the entire scene to achieve a higher level of quality.\r\n\r\nThe CloudLight paper is a first attempt into rendering games in the cloud. Traditional techniques for parallel rendering don't translate well towards rendering games for many clients, and as the number of clients increases much of the work becomes duplicated. With many clients connecting to a single cloud, this allows us to perform operations that would traditionally be too expensive for a single user, and amortize the cost across many clients. One such possibility for amortiziation is Global Illumination.\r\n\r\nThe irradiance map solution proposed is comprised primarily of two parts:\r\n\r\n1. A cloud side raytracer which aggregates diffuse reflections to a global illumination lightmap, which is then H.264 encoded and streamed to the client as a video.\r\n2. The client side renderer, which is just a typical renderer with lightmap support. The only difference here is the client now needs to decode the H.264 stream, and update the lightmap as it receives them.\r\n\r\n### Challenge\r\nLaunching a separate instance of a raytracer for every viewport is clearly inefficient if multiple viewports are sharing a scene. We need to break down the problem into portions that are viewport independent and those that aren't, allowing us to amortize the cost of operations across many viewports. Global illumination is one component of a scene that is viewport independent, and as such can be amortized across clients.\r\n\r\nGlobal illumination is very expensive to compute, and requires a significant amount of processing power on the client side. As such, without a sufficient GPU it becomes impossible to compute global illumination while keeping real time framerates. However global illumination is a very attractive feature to have, as it increases the realism of a rendered scene.\r\n\r\nNotable challenges would be the amount of components that need to be implemented: a remote side raytracer, networking code, as well as the client side code to piece information together and incorporate it into its rendering pipeline.\r\n\r\n### Resources\r\nIn a similar vein to the paper, multiple frameworks would be used to speed up development times of the various components.\r\n\r\nRaytracing  -   OptiX\r\nNetworking  -   Asio / SDL_net\r\nWindow      -   SDL / GLFW\r\nGraphics    -   OpenGL\r\nH.264       -   C++ / libav / FFmpeg\r\n\r\nClient side would probably be my laptop. Access to a machine with a beefy GPU that I could run at a whim (Gates / latedays / other) would be used for the cloud side.\r\n\r\nCode would be written from scratch.\r\n\r\n### Platform\r\nThe platform chosen is due to tradeoffs between performance and creation time. Using OptiX will hopefully speed up creation of the cloud side raytracer. The remaining platform components are typical of games, and since CloudLight is targeted towards rendering games it makes sense to use a system similar to this.\r\n\r\n### Goals and Deliverables\r\nPlan to achieve:\r\nDemonstrate a system with multiple viewports interacting with a single remote server, and compare performance to a system where work is not amortized.\r\n\r\nHope to achieve:\r\nIntegrate this with Yong's system\r\n\r\n### Schedule\r\nApril 1: Become confused  \r\nApril 4: Talk to Yong  \r\nApril 5: Talk to Kayvon  \r\nApril 5: Formulate a concrete project idea  \r\nApril 9: Crude raytracer in OptiX  \r\nApril 16: Crude renderer in OpenGL  \r\nApril 22: Irradiance map creation in OptiX  \r\nApril 29: Implement irradiance map in OpenGL  \r\nMay 6: Communication code between host and client  \r\nMay 9: Feel accomplished (hopefully)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}