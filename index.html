<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>15418-project by THofstee</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>15418-project</h1>
        <p>Final project for CMU 15-418.</p>

        <p class="view"><a href="https://github.com/THofstee/15418-project">View the Project on GitHub <small>THofstee/15418-project</small></a></p>


        <ul>
          <li><a href="https://github.com/THofstee/15418-project/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/THofstee/15418-project/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/THofstee/15418-project">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h2>
<a id="proposal" class="anchor" href="#proposal" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Proposal</h2>

<h3>
<a id="summary" class="anchor" href="#summary" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Summary</h3>

<p>I will implement the irradiance map solution of <a href="https://research.nvidia.com/publication/cloudlight-system-amortizing-indirect-lighting-real-time-rendering/">CloudLight</a> and compare performance and quality tradeoffs to local computation.</p>

<h3>
<a id="background" class="anchor" href="#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Background</h3>

<p>Cloud rendering is a promising platform for graphics rendering in the future. Rendering (games) in the cloud has the potential for methods that would be unreasonable for a local machine, such as possibly raytracing the entire scene to achieve a higher level of quality.</p>

<p>The CloudLight paper is a first attempt into rendering games in the cloud. Traditional techniques for parallel rendering don't translate well towards rendering games for many clients, and as the number of clients increases much of the work becomes duplicated. With many clients connecting to a single cloud, this allows us to perform operations that would traditionally be too expensive for a single user, and amortize the cost across many clients. One such possibility for amortiziation is Global Illumination.</p>

<p>The irradiance map solution proposed is comprised primarily of two parts:</p>

<ol>
<li>A cloud side raytracer which aggregates diffuse reflections to a global illumination lightmap, which is then H.264 encoded and streamed to the client as a video.</li>
<li>The client side renderer, which is just a typical renderer with lightmap support. The only difference here is the client now needs to decode the H.264 stream, and update the lightmap as it receives them.</li>
</ol>

<h3>
<a id="challenge" class="anchor" href="#challenge" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Challenge</h3>

<p>Launching a separate instance of a raytracer for every viewport is clearly inefficient if multiple viewports are sharing a scene. We need to break down the problem into portions that are viewport independent and those that aren't, allowing us to amortize the cost of operations across many viewports. Global illumination is one component of a scene that is viewport independent, and as such can be amortized across clients.</p>

<p>Global illumination is very expensive to compute, and requires a significant amount of processing power on the client side. As such, without a sufficient GPU it becomes impossible to compute global illumination while keeping real time framerates. However global illumination is a very attractive feature to have, as it increases the realism of a rendered scene.</p>

<p>Notable challenges would be the amount of components that need to be implemented: a remote side raytracer, networking code, as well as the client side code to piece information together and incorporate it into its rendering pipeline.</p>

<h3>
<a id="resources" class="anchor" href="#resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Resources</h3>

<p>In a similar vein to the paper, multiple frameworks would be used to speed up development times of the various components.</p>

<p>Raytracing  -   OptiX
Networking  -   Asio / SDL_net
Window      -   SDL / GLFW
Graphics    -   OpenGL
H.264       -   C++ / libav / FFmpeg</p>

<p>Client side would probably be my laptop. Access to a machine with a beefy GPU that I could run at a whim (Gates / latedays / other) would be used for the cloud side.</p>

<p>Code would be written from scratch.</p>

<h3>
<a id="platform" class="anchor" href="#platform" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Platform</h3>

<p>The platform chosen is due to tradeoffs between performance and creation time. Using OptiX will hopefully speed up creation of the cloud side raytracer. The remaining platform components are typical of games, and since CloudLight is targeted towards rendering games it makes sense to use a system similar to this.</p>

<h3>
<a id="goals-and-deliverables" class="anchor" href="#goals-and-deliverables" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Goals and Deliverables</h3>

<p>Plan to achieve:
Demonstrate a system with multiple viewports interacting with a single remote server, and compare performance to a system where work is not amortized.</p>

<p>Hope to achieve:
Integrate this with Yong's system</p>

<h3>
<a id="schedule" class="anchor" href="#schedule" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Schedule</h3>

<p>April 1: Become confused
April 4: Talk to Yong
April 5: Talk to Kayvon
April 5: Formulate a concrete project idea
April 9: Crude raytracer in OptiX
April 16: Crude renderer in OpenGL
April 22: Irradiance map creation in OptiX
April 29: Implement irradiance map in OpenGL
May 6: Communication code between host and client
May 9: Feel accomplished (hopefully)</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/THofstee">THofstee</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
